You are an expert full-stack developer. Build a **fully functional, secure, and accurate â€œPDF to PowerPointâ€ conversion tool** with complete backend and frontend code â€” **no AI (OpenAI, Gemini, or third-party APIs)** must be used. The tool must process all PDFs locally and support scanned PDFs via OCR.

ğŸ¯ GOAL:
Convert any `.pdf` file (max 50MB) into a **real, editable `.pptx` file**:
- For text-based PDFs: Extract text and structure it into PowerPoint slides.
- For scanned PDFs (image-based): Use OCR to extract text and then structure it into slides.
- Layout must be preserved as accurately as possible.
- Images and tables from PDF must also be placed into corresponding slides if present.

ğŸ§  CORE BACKEND LOGIC:
Use Python with Flask for the backend. Do not use dummy or placeholder code â€” all conversion logic must be fully implemented using the following open-source libraries:

1. `PyMuPDF` or `pdfminer.six` â†’ extract content from text-based PDFs.
2. `pdf2image` + `pytesseract` â†’ for OCR on scanned PDFs (convert pages to images, extract text).
3. `python-pptx` â†’ build `.pptx` slides dynamically.
4. `Flask`, `uuid`, `threading`, and `tempfile` â†’ for secure file handling and download logic.

ğŸ” FILE VALIDATION:
- Accept only `.pdf` files, max 50MB.
- Validate extension and MIME type.
- Check for text content density to detect whether itâ€™s a scanned (image-based) or text-based PDF.

ğŸ“„ SLIDE GENERATION RULES:
- Each PDF page = 1 PowerPoint slide.
- Add headers, paragraphs, or bullet points based on logical separation in content.
- Embed images from PDF pages as slide backgrounds (optional).
- Text boxes must follow the document layout (left-aligned, center-aligned, etc.).
- Use font size and styles to preserve hierarchy (e.g., bold = header).

ğŸ‘ï¸â€ğŸ—¨ï¸ SCANNED PDF LOGIC:
- If PDF has minimal extractable text, treat it as scanned.
- Convert each page to an image using `pdf2image`.
- Use `pytesseract` OCR to extract text.
- Build slides from OCR results â€” one slide per page.
- Show fallback message in slide if OCR fails for a page.

ğŸ“ FILE STORAGE + DOWNLOAD SECURITY:
- Uploaded PDFs and generated `.pptx` files must be stored temporarily in a `/tmp` directory.
- On successful conversion, return a secure hashed download link (`/download/<uuid>`) to the frontend.
- Auto-delete both input and output files after 4 minutes (240 seconds) using background threads or cleanup scheduler.

ğŸ›¡ï¸ SECURITY RULES:
- Never expose file paths or server internals.
- Prevent access to expired files with proper route validation.
- Return friendly error messages for:
  - Unsupported file type
  - Corrupt PDF
  - OCR failure
  - File size exceeded
  - Download expired

ğŸ§ª LOGGING (Optional):
- Log filename, conversion status, timestamp, and optional IP address for debugging or analytics (in a secure log file).

---

ğŸ¨ FRONTEND UI (NO FRAMEWORKS):
Build a modern, animated, lightweight, **3D-styled frontend** using HTML, CSS (with glassmorphism + neon shadows), and vanilla JavaScript.

ğŸ¯ UI REQUIREMENTS:
1. Clean single-page interface with drag & drop file upload + browse button.
2. Show animated Lottie loader or SVG spinner while conversion is processing.
3. Display progress using animated progress bar or text updates.
4. On success, show a **large glowing download button** with countdown timer (4 min remaining).
5. On failure, show animated error box with retry option.
6. Use 3D hover effects, glowing cards, floating containers, and smooth transitions.
7. Fully responsive for:
   - Mobile phones (portrait view)
   - Tablets (adaptive scaling)
   - Desktops (grid-based UI)
8. Use accessible elements (buttons, labels, aria tags) and keyboard navigability.

---

ğŸ“¦ OUTPUT PROJECT FILES:
Return the complete working code for:

- `app.py` â†’ Flask backend
- `index.html` â†’ Modern frontend UI
- `style.css` â†’ All custom 3D glass UI animations and styles
- `main.js` â†’ Upload logic, progress bar, download timer
- `requirements.txt` â†’ All backend libraries
- `/tmp` â†’ Temporary file store (auto-created)
- `cleanup.py` or inline thread logic â†’ for auto-deleting files after 4 minutes

---

ğŸ§  FUNCTIONALITY SUMMARY:

- âœ… Accept `.pdf` file from user
- âœ… Validate file type and size
- âœ… Detect whether PDF is scanned or text-based
- âœ… Extract content (text or OCR)
- âœ… Convert to `.pptx` using `python-pptx`
- âœ… Securely store in `/tmp/`
- âœ… Return secure, expiring download link (4 minutes)
- âœ… Frontend shows animated progress + download button
- âœ… Delete files automatically after expiry
- âœ… No blank or corrupt files
- âœ… No use of OpenAI, Gemini, or external AI
- âœ… Fully working backend + frontend
- âœ… Lightweight, 3D-animated UI (no slowdowns on mobile)

---

ğŸš« MUST NOT:
- âŒ Use any AI APIs (e.g., OpenAI, Gemini, Claude)
- âŒ Use dummy or placeholder logic
- âŒ Use cloud services for OCR or conversion
- âŒ Expose server paths or create insecure endpoints
- âŒ Skip OCR logic â€” even scanned PDFs must be processed
- âŒ Produce blank or damaged `.pptx` output

---

âœ… BONUS:
Use `uuid.uuid4()` to generate unique filenames for both uploaded and output files. Set MIME type correctly for PPTX download. Show proper toast notifications (success/failure) on frontend with icons or slide-in animations.

---

This tool must run **fully locally** inside Replit with real backend logic, and must be fast, secure, and visually impressive across all devices. Return the entire working project â€” ready to test, deploy, and use immediately.

